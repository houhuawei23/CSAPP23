# y86\_64\_sim.py

侯华玮 202102001015

这段代码主要实现了一个Y86-64指令集模拟器，定义了相关的枚举类、内存类、通用寄存器类、流水线寄存器类等。

1.  枚举类：
    -   ICODE：定义了Y86-64指令集中的指令代码。
    -   STAT：定义了模拟器运行状态。
    -   RF：定义了通用寄存器名称。
    -   ALUFUN：定义了ALU功能。
2.  内存类（Memory）：
    -   初始化：创建一个大小为1024的内存空间。
    -   读取内存：提供两种方法，一个返回字符串形式的数据，另一个返回整数形式的数据。
    -   写入内存：将数据写入指定地址。
    -   加载程序：从文件中加载程序到内存中。
3.  通用寄存器类（ComRegs）：
    -   初始化：创建一个大小为16的寄存器数组，以及PC、iReg、ZF、SF、OF等寄存器。
    -   读取寄存器：根据寄存器编号读取寄存器值。
    -   写入寄存器：根据寄存器编号写入寄存器值。
    -   打印寄存器信息：显示所有寄存器的状态。
4.  流水线寄存器类：
    -   WBIF：定义了预测PC寄存器。
    -   IFID：定义了指令取指和译码阶段的寄存器。
    -   IDEX：定义了译码和执行阶段的寄存器。
    -   EXMEM：定义了执行和访存阶段的寄存器。
    -   MEMWB：定义了访存和写回阶段的寄存器。 每个流水线寄存器类都包含一个update方法用于更新寄存器的状态，以及一个print方法用于打印寄存器的状态。
5.  `Processor`类，这个类是用于实现一个Y86-64指令集模拟器的。`Processor`类中的主要数据结构如下：
    1.  类实例化时，包含了以下成员：
        -   mem：Memory类的实例
        -   wbif、ifid、idex、exmem、memwb：分别代表五个流水线寄存器，分别用五个类的实例表示
        -   comregs：ComRegs类的实例，用于存储状态寄存器
        -   Stat：程序运行状态
    2.  类的主要方法：
        -   `__init__`：初始化方法，为Processor的实例创建必要的属性。
        -   `setcc`：根据输入的valE设置条件码寄存器。
        -   `cond`：根据输入的ifun判断条件是否满足。
        -   `print`：打印Processor的各个寄存器的值。
        -   `ifetch`：取指令操作，获取当前PC对应的指令并对其进行解析。
        -   `idecode`：译码函数，根据输入与数据旁路的信息，读取寄存器文件。
        -   `execute`：根据指令代码和功能执行ALU操作，计算结果和相关寄存器的值。
        -   `memory`：负责执行内存读写操作，如加载和存储指令、栈操作等。
        -   `writeback`：将执行结果写回到目标寄存器。
        -   `control_logic`：负责处理流水线冒险和异常情况。
        -   `run`：流水线的主要驱动函数

***

`ifetch`方法是处理指令取址阶段的函数，负责选择程序计数器（PC）的值、读取内存中的指令、解码指令、计算下一个PC的值以及设置状态。

以下是这个方法的主要步骤：

1.  **选择PC**: 根据前一阶段的指令和条件决定PC的值。
2.  **读取内存**: 从内存中读取指定PC地址的10个字节，用于解码指令。
3.  **解码指令**: 解码指令的操作码（opcode）和功能码（ifun）。同时检查指令是否有效，以及是否需要读取寄存器ID（regids）和立即数值（valC）。
4.  **对齐**: 根据解码的指令信息，提取相应的寄存器ID和立即数值。
5.  **计算下一个PC**: 计算下一个指令的PC值，包括预测跳转指令的目标地址。
6.  **设置状态**: 根据读取内存的结果、指令有效性、以及指令本身来设置状态。

***

`idecode`方法是译码函数，根据输入与数据旁路的信息，读取寄存器文件。

函数的输入参数包括：`e_dstE`（执行阶段的目的寄存器），`e_valE`（执行阶段计算得到的值），`m_valM`（访存阶段从内存读取的值）。

代码的结构和实现逻辑如下：

1.  初始化局部变量，包括指令的状态（`d_stat`）、操作码（`d_icode`）、功能码（`d_ifun`）等。
2.  获取IFID（指令获取/译码）阶段的相关寄存器值。
3.  获取EXMEM（执行/访存）阶段的相关寄存器值。
4.  获取MEMWB（访存/写回）阶段的相关寄存器值。
5.  根据指令的操作码（`self.ifid.icode`），确定目的寄存器`d_dstE`和`d_dstM`。
6.  根据指令的操作码（`self.ifid.icode`），确定源寄存器`d_srcA`和`d_srcB`。
7.  读取寄存器文件中`d_srcA`和`d_srcB`对应的值`d_rvalA`和`d_rvalB`。
8.  实现数据前推，解决数据冒险。根据指令类型和源寄存器与目的寄存器之间的关系，确定`d_valA`和`d_valB`的值。
9.  将计算得到的状态、操作码、功能码等局部变量打包成一个元组`next_idex`，以便传递给下一阶段。
10. 返回`next_idex`和`forwarding`（源寄存器的前推信息）。

***

`execute(self, m_stat)`: 此方法根据指令代码和功能执行ALU操作，计算结果和相关寄存器的值。它还负责设置条件码和条件跳转的结果。此方法返回下一个EXMEM阶段的值和一些转发信息。

函数的输入参数包括：`m_stat`（访存阶段的状态）。

代码的结构和实现逻辑如下：

1.  获取IDEX（译码/执行）阶段的相关寄存器值。
2.  根据指令的操作码（`idex_icode`），确定ALU的输入A（`aluA`）和输入B（`aluB`）的值。
3.  如果指令是算术指令，设置ALU功能码（`alufun`）为译码阶段的功能码（`idex_ifun`）；否则，设置ALU功能码为加法。
4.  判断是否发生内存异常（`memexp`）或写回异常（`wbexp`）。
5.  如果当前指令是算术指令，没有发生内存异常和写回异常，则设置条件码（`set_cc`）；否则，不设置条件码。
6.  根据ALU功能码（`alufun`）和ALU输入A、B的值，计算执行阶段得到的值（`e_valE`）。
7.  如果需要设置条件码，调用`setcc`函数设置条件码（零标志ZF、符号标志SF、溢出标志OF）。
8.  计算执行阶段的条件（`e_cnd`），根据译码阶段的功能码（`idex_ifun`）和当前的条件码。
9.  对于条件传送指令，只有在条件成立时才设置目的寄存器（`e_dstE`）；否则，将目的寄存器设置为RNONE。
10. 将计算得到的状态、操作码、条件等局部变量打包成一个元组`next_exmem`，以便传递给下一阶段。
11. 返回`next_exmem`和`forwarding`（目的寄存器的前推信息）。

该`execute`函数执行指令并处理数据冒险，以便在模拟y86-64指令集的过程中正确执行指令。

***

`memory(self)`: 此方法负责执行内存读写操作，如加载和存储指令、栈操作等。

如果在内存访问过程中发生错误，它会设置相应的状态。此方法返回下一个MEMWB阶段的值和一些转发信息。

代码的结构和实现逻辑如下：

1.  获取EXMEM（执行/访存）阶段的相关寄存器值。
2.  根据指令的操作码（`exmem_icode`），确定访存操作的地址（`mem_addr`）。
3.  判断是否需要进行内存读取操作（`mem_read`）。
4.  判断是否需要进行内存写入操作（`mem_write`）。
5.  初始化数据内存错误标志（`dmem_error`）。
6.  如果需要进行内存读取操作，从内存中读取数据（`m_valM`）。如果读取失败，设置数据内存错误标志。
7.  如果需要进行内存写入操作，将数据（`exmem_valA`）写入内存。如果写入失败，设置数据内存错误标志。
8.  如果发生数据内存错误，设置访存阶段的状态（`m_stat`）为ADR；否则，使用执行阶段的状态（`exmem_stat`）。
9.  将计算得到的状态、操作码等局部变量打包成一个元组`next_mwmwb`，以便传递给下一阶段。
10. 返回`next_mwmwb`和`forwarding`（内存数据的前推信息）。

该`memory`函数处理内存访问操作，以便在模拟y86-64指令集的过程中正确执行指令。

***

`writeback(self)`: 此方法负责将执行结果写回到目标寄存器。此方法没有返回值，但会更新Processor类的状态。

代码的结构和实现逻辑如下：

1.  将内存/写回阶段（MEMWB）的`valM`值写回到目标寄存器`dstM`。
2.  将内存/写回阶段（MEMWB）的`valE`值写回到目标寄存器`dstE`。
3.  如果内存/写回阶段的状态为BUB（气泡），则将处理器的状态`Stat`设置为AOK（正常执行）；否则，将处理器的状态设置为内存/写回阶段的状态。
4.  定义一个空元组`next_wbif`，用于传递给下一阶段（在这种情况下，没有下一阶段，因此为空）。
5.  返回`next_wbif`和`forwarding`（写回数据的前推信息）。

***

`control_logic`方法负责处理流水线冒险和异常情况。

它根据指令和执行结果来确定是否需要插入气泡（bubble）或暂停（stall）流水线的各个阶段。这有助于确保在出现加载/使用冒险、分支预测错误和RET指令时，流水线能够正确执行。

该函数接收四个输入参数：`d_srcA`、`d_srcB`、`e_cnd`和`m_stat`，用于判断是否需要插入气泡（bubble）或暂停（stall）流水线中的某个阶段。

代码的结构和实现逻辑如下：

1.  初始化所有阶段的气泡和暂停信号为0。
2.  判断是否存在加载使用冒险（load-use hazard）、返回指令（ret）和分支预测错误（mispredicted branch）的情况。
3.  如果存在加载使用冒险或返回指令，将写回/指令获取（WBIF）阶段的暂停信号设置为1。
4.  如果存在加载使用冒险且返回指令，将指令获取/译码（IFID）阶段的气泡信号设置为0；如果存在分支预测错误或返回指令，将IFID阶段的气泡信号设置为1。
5.  如果存在加载使用冒险，将IFID阶段的暂停信号设置为1。
6.  如果存在加载使用冒险或分支预测错误，将译码/执行（IDEX）阶段的气泡信号设置为1。
7.  如果内存（MEM）阶段或写回（WB）阶段存在异常（ADR、INS或HLT状态），将执行/内存（EXMEM）阶段的气泡信号设置为1。
8.  如果WB阶段存在异常，将MEM/WB阶段的暂停信号设置为1。

最后，函数返回所有阶段的气泡和暂停信号，用于控制流水线的运行。这些信号将根据不同的冒险或异常情况调整流水线的执行，以确保正确地执行指令。

***

`run`方法是整个流水线的主要驱动函数。

它首先调用`writeback`、`memory`、`execute`、`idecode`和`ifetch`方法，以获取各阶段的输出。然后，`run`方法调用`control_logic`方法来确定是否需要插入气泡或暂停。最后，根据`control_logic`方法的结果更新流水线寄存器（如`wbif`、`ifid`、`idex`、`exmem`和`memwb`）。

`run`方法通过调用各个阶段的方法来驱动整个流水线，并根据`control_logic`方法的结果处理流水线冒险和异常。这样可以确保流水线在处理冒险和异常时能够正确执行。
